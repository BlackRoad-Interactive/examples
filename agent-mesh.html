<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BlackRoad Agent Mesh</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; color: #fff; font-family: -apple-system, monospace; overflow: hidden; }
    canvas { display: block; }
    #ui {
      position: fixed; top: 20px; left: 20px; z-index: 10;
      display: flex; flex-direction: column; gap: 8px;
    }
    .agent-badge {
      display: flex; align-items: center; gap: 8px;
      background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.1);
      border-radius: 4px; padding: 6px 10px; font-size: 12px;
    }
    .dot { width: 10px; height: 10px; border-radius: 50%; }
    #status { position: fixed; bottom: 20px; left: 20px; font-size: 11px; opacity: 0.5; }
  </style>
</head>
<body>
  <div id="ui">
    <div class="agent-badge"><div class="dot" style="background:#9C27B0"></div> LUCIDIA — Reasoning</div>
    <div class="agent-badge"><div class="dot" style="background:#4CAF50"></div> ALICE — Worker</div>
    <div class="agent-badge"><div class="dot" style="background:#2196F3"></div> OCTAVIA — DevOps</div>
    <div class="agent-badge"><div class="dot" style="background:#FF9800"></div> PRISM — Analytics</div>
    <div class="agent-badge"><div class="dot" style="background:#00BCD4"></div> ECHO — Memory</div>
    <div class="agent-badge"><div class="dot" style="background:#F44336"></div> CIPHER — Security</div>
  </div>
  <div id="status">BlackRoad OS — Agent Mesh Visualization</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    const AGENTS = [
      { name: 'LUCIDIA', color: 0x9C27B0, pos: [0, 0, 0], size: 1.8 },
      { name: 'ALICE',   color: 0x4CAF50, pos: [8, 3, 2],  size: 1.2 },
      { name: 'OCTAVIA', color: 0x2196F3, pos: [-8, -2, 3], size: 1.2 },
      { name: 'PRISM',   color: 0xFF9800, pos: [3, 8, -2],  size: 1.2 },
      { name: 'ECHO',    color: 0x00BCD4, pos: [-3, -7, -1],size: 1.2 },
      { name: 'CIPHER',  color: 0xF44336, pos: [0, 2, -9],  size: 1.2 },
    ];

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
    camera.position.z = 22;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // Lights
    scene.add(new THREE.AmbientLight(0x222222));
    const pLight = new THREE.PointLight(0xffffff, 1, 60);
    pLight.position.set(5, 5, 10);
    scene.add(pLight);

    // Stars
    const starGeo = new THREE.BufferGeometry();
    const starPos = new Float32Array(3000 * 3);
    for (let i = 0; i < 9000; i++) starPos[i] = (Math.random() - .5) * 300;
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
    scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.08 })));

    // Agent meshes
    const meshes = AGENTS.map(a => {
      const mat = new THREE.MeshPhongMaterial({
        color: a.color, emissive: a.color, emissiveIntensity: 0.4, shininess: 100
      });
      const mesh = new THREE.Mesh(new THREE.SphereGeometry(a.size, 32, 32), mat);
      mesh.position.set(...a.pos);
      mesh.userData = a;
      scene.add(mesh);
      return mesh;
    });

    // Connection lines (all to LUCIDIA)
    const lucidia = meshes[0];
    meshes.slice(1).forEach(m => {
      const pts = [lucidia.position.clone(), m.position.clone()];
      const geo = new THREE.BufferGeometry().setFromPoints(pts);
      const mat = new THREE.LineBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.4 });
      scene.add(new THREE.Line(geo, mat));
    });

    // Animate
    let t = 0;
    function animate() {
      requestAnimationFrame(animate);
      t += 0.005;
      meshes.forEach((m, i) => {
        m.rotation.y += 0.01;
        m.position.y += Math.sin(t + i) * 0.002;
      });
      camera.position.x = Math.sin(t * 0.1) * 3;
      camera.position.y = Math.cos(t * 0.07) * 2;
      camera.lookAt(0, 0, 0);
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
